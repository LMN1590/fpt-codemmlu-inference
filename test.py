import uuid
import json
from typing import List,Dict
import re
import xml.etree.ElementTree as ET 
# from setup import MultipleChoiceQuestion
def parse_LLM_output_to_valid_JSON(output:str)->str:
    return output.replace("\n"," ").replace("\t"," ")
def parse_xml(llm_output:str):
    tree = ET.fromstring('<xml>'+llm_output+'</xml>')
    output_res = {}
    for child in tree:
        output_res[child.tag] = child.text
    return output_res
PATH_SET = """""* Review the Multiple-Choice Question and its answer carefully, focusing on software testing methodologies, system design, and quality assurance metrics.\n* Verify the candidate's understanding of:\n  * Software testing methodologies (stress testing, load testing, performance testing)\n  * System design and architecture (bottlenecks, single points of failure)\n  * Quality assurance metrics (reliability, stability, scalability)\n  * Data structure properties (heap, stack, queue) and their implications on time and space complexity\n  * Algorithmic trade-offs (hash tables, binary search trees, graphs) in system design and software engineering\n  * Concurrency control mechanisms (locks, semaphores, monitors) and their application in database 
query optimization and system design\n  * Loop termination conditions and potential infinite loops\n  * Algorithmic time complexity and its implications on system performance\n  * Trade-offs between programming paradigms (OOP, functional, procedural) and their impact on system design, scalability, and reliability\n  * Computer architecture concepts (microprogramming, pipelining, cache memory) and their impact on system performance and design\n  * System design principles (scalability, availability, fault tolerance) and their implications on software engineering and quality assurance metrics\n  * String manipulation algorithms (loop boundary conditions, trade-offs between algorithms)\n  * Networking protocols (TCP/IP, DNS, DHCP) and network architecture\n  * Network security measures (firewalls, VPNs, encryption protocols)\n  * Database concepts (data modeling, normalization, query optimization)\n  * System call parameters and socket programming concepts\n  * Dynamic programming concepts (memoization, tabulation) and 
their application in optimizing algorithmic solutions\n  * Closure properties in programming languages and their implications on 
variable scope and function calls\n  * Data type compatibility and potential precision issues in mathematical functions\n  * Error mitigation strategies for data type mismatches and numerical stability\n  * Recursive function calls and correct parameter updates to prevent infinite loops or incorrect results\n  * Algorithmic modifications for correctness and intended functionality\n  * Trade-offs between recursive and iterative approaches in algorithms\n  * System flowchart notation and software engineering principles\n  * Configuration management principles (version control, change management, documentation)\n  * Loop boundary conditions in two-pointer technique implementations to prevent index out-of-range errors\n  * Impact of pointer movement on algorithm correctness, considering left and right pointer adjustments\n  * Trade-offs between algorithmic approaches (two-pointer technique, binary search) in terms of time complexity, space complexity, and scalability\n  * Potential null pointer exceptions in object-oriented programming and verification of object initialization\n  * Trade-offs between monolithic architecture and microservices architecture in system design, considering scalability, maintainability, and communication overhead\n  * Implications of cache coherence protocols on concurrent system performance, including cache misses and synchronization mechanisms\n  * Correct usage of socket programming concepts (accept, listen) for client connection handling\n  * Trade-offs between concurrency control mechanisms (threads, processes, async/await) in system design, considering scalability, performance, and complexity\n  * Implications of error handling strategies on system reliability and stability, including try-catch blocks and logging mechanisms\n  * Correct application of dynamic programming principles (memoization, tabulation) to optimize algorithmic solutions\n  * Trade-offs between data structures (arrays, linked lists, hash tables) in terms of time and space complexity, and their suitability for various problem domains\n  * Implications of system design principles (scalability, availability, fault tolerance) on software engineering and quality assurance metrics\n  * Array initialization techniques to ensure correct initialization for algorithmic operations\n  * Trade-offs between programming paradigms (OOP, functional, procedural) in terms of code readability, maintainability, and scalability\n  
* Implications of variable scope and closure properties on function calls and variable updates, considering local and global variable interactions\n  * B+ tree node capacity calculations to ensure accurate accounting for key and pointer storage\n  * Trade-offs between data structure implementations (B-trees, hash tables, heaps) in terms of search, insertion, and deletion operations, and their suitability for database and file system applications\n  * Implications of system design principles on data structure and algorithmic choices, and verification of their correct application in system design\n  * Loop boundary conditions in nested iterations to prevent index out-of-range errors and ensure correct loop termination\n  * Trade-offs between algorithmic approaches (dynamic programming, greedy algorithms) in terms of time complexity, space complexity, and scalability\n  * Implications of concurrency control mechanisms on system performance and reliability, considering deadlock prevention and synchronization overhead\n  
* Class and function definitions to prevent undefined references and ensure correct compilation, considering built-in and custom 
data types\n  * Implications of recursive function calls on system performance and reliability, evaluating potential stack overflow errors and incorrect results due to inadequate base cases or parameter updates"""
print(PATH_SET)